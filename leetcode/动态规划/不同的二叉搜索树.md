# 不同的二叉搜索树
[题目链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)

## 1.题解
&emsp;&emsp; 对于此题首先得明确二叉搜索树得一些基本概念，左子树的键值比节点的键值
要小，右子树的键值都大于节点键值,要求给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
题目中明确了给定的数为整数，因此数字0不在考虑范围内。`[1, 2, 3, 4, 5, 6, 7, 8]`为测试用例来说明，遍历其中的每个元素作为根节点，例如以5作为根节点那么
5左侧即为左子树，右侧的即为右子树，再在左右序列中递归的构建二叉树。

&emsp;&emsp;本地采用动态规划的方式去解决，需要确定一下的三个内容:
* 定义状态（最优子结构、大量重复子问题）
* 寻找决策（状态转移方程）
* 确定初值（边界条件）

1. 定义状态
&emsp;&emsp;以`F(i, n)`表示以i为根节点的长度为n序列可以构成的二叉搜索的个数，以T(n)表示了长度为n的
序列可以构成二叉搜索树的个视，如果根节点确定以后左右两端的序列长度为0，或者1，那么`T(0)=T(1)=1`

2. 确定状态转移方程

&emsp;&emsp;`F(i, n) = T(i-1) * T(n-1), T(n)=sum(F(i, n)) (1<=i<=n)`需要注意的能够二叉树个数的多少
只与序列的长度有关。


3. 边界值

&emsp;&emsp;当序列长度为1（只有根节点）或者为0（空树）的时候，可以构建的二叉树的个数都为0，即T(0)=T(1)=1


## code

&emsp;&emsp;动态规划中都会只用数组来记录当前的dp的状态,代码中的dp即表示上文题解中的T。


    class Solution:
        def numTrees(self, n):
            dp = [0 for i in range(n+1)] 表示长度n的序列可构成的树的个数    
            dp[0], dp[1] = 1, 1   # 边界值
            for i in range(2, (n+1)):  dp计算长度为n的序列可构成的树的个数 
                for j in range(1, i+1):  # 确定根节点的位置   
                    dp[i] += dp[j-1] * dp[i-j]      
        
            return dp[n]    
            
#   不同的二叉搜索树 ii
&emsp;&emsp;
[leetcode95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)
本题与上一题的思路还是一样的，只是本题需要对构建的二叉树进行输出,有关二叉树的构建可以查看树整理部分的内容

&emsp;&emsp;根据二叉搜索树的性质，在长度为n的序列中，确定了第i个元素为根节点，那么左子树为`[0：i-1
]`，右子树为`[i+1, n-1]`,并且对于左右子树中又可以按照上面的方式递归构建二叉搜索树。
