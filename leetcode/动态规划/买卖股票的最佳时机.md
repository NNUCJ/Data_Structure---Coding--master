# 最佳买卖股票时机含冷冻期
题目描述：  [Link](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
&emsp;&emsp;给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

&emsp;&emsp;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

&emsp;&emsp;1. 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。  
&emsp;&emsp;2. 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。


## 1. 题解
&emsp;&emsp;仍采用动态规划的方式对此题进行解决，测试样例`[1,2,3,0,2]`,注解`[买入, 卖出, 冷冻期, 买入, 卖出]`
&emsp;&emsp;本地采用动态规划的方式去解决，需要确定一下的三个内容:
* 定义状态（最优子结构、大量重复子问题）
* 寻找决策（状态转移方程）
* 确定初值（边界条件）

### 1.1 定义状态

定义状态f(i)表示第i天结束股市结束后的最大收益,根据题意共有以下的三种状态：

1. 持有一种股票，不在冷冻区， 对应的最大收益为`f[i][0]`;
2. 不持有股票，并且处于冷冻区，对用的最大收益记为`f[i][1]`
3. 不持有股票，并且不处于冷冻区，对用的最大收益记为`f[i][2]`

### 1.2 状态转移
&emsp;&emsp;第i天的状态从第i-1天状态转移而来，可以进行买入以及卖出操作，也可以不进行任何操作 等于`i-1`天的状态。

* 对于`f[i][0]`的最大收益，这支股票可以是第i-1天就已经在手中了，对应的状态`f[i-1][0]`;
  或者是第i天买入的，那么第i-1天就不能在冷冻期，对应的状态为`f[i-1][2]`加上买入股票价格负收益`price[i]`,因此状态转移方程为：
    
        f[i][0] = max(f[i-1][0], f[i-1][2]-prices[i])
 
* 对于`f[i][1]`,第i天卖出股票之后不持有任何股票处于冷冻区，说明第i-1天必须持有
  股票，对应的状态为`f[i-1][0]`加上卖出收益`prices[i]`,因此状态方程为：
  
       f[i][1] = f[i-1][0]+prices[i]
       
* 对于`f[i][2]`,不持有股票并且不在冷冻区，说明当天没有买入也没有卖出的，即第i-1天
  不持有任何股票：如果处于冷冻期，对应的状态为`f[i-1][1]`;如果不处在冷冻期对应状态`f[i-1][2]`
  
  
这样得到所有的状态方程，如果一共有n天，那么最终的状态转移方程为

    max(f[n-1][0], f[n-1][1], f[n-1][2])
    
 如果到了最后一天（第n-1天）手上仍然持有股票，那么收益肯定不是最大，因此状态方程可以变为
 
    max(f[n-1][1], f[n-1][2])
    
 ### 1.3 临界点
 
 第0天的设为临界点：
    
    f[0][0] = -prices[0]  第0天买入股票
    f[0][1]=0  尽管不存在第0天就是冷冻期
    f[0][2]=0  不买股票
    

#### 代码

    class Solution:
    def maxProfit(self, prices):
        if not prices:
            return 0

        n = len(prices)
        dp = [[-prices[0], 0, 0]] + [[0] * 3 for _ in range(n - 1)]  # 构建dp数组存储状态

        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i])
            dp[i][1] = dp[i - 1][0] + prices[i]
            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2])

        return max(dp[n - 1][1], dp[n - 1][2])